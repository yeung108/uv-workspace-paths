/** @format */

import * as fs from "fs/promises";
import type { DependencyGraph, WorkspaceFile } from "./types.js";

const GENERATED_COMMENT =
  "// Auto-generated by uv-workspace-paths extension. Do not edit manually.";

/**
 * Update the .code-workspace file with per-folder extraPaths settings.
 */
export async function updateWorkspaceFile(
  workspacePath: string,
  dependencyGraph: DependencyGraph,
): Promise<{ updated: boolean; foldersUpdated: number }> {
  const content = await fs.readFile(workspacePath, "utf-8");

  // Parse JSON with comments (VS Code workspace files support comments)
  const cleanedContent = removeJsonComments(content);
  const workspace: WorkspaceFile = JSON.parse(cleanedContent);

  workspace.settings = workspace.settings || {};

  // Track what folder names exist in the workspace
  const workspaceFolderNames = new Set(
    workspace.folders.map((f) => f.name || getBasename(f.path)),
  );

  // Clear old folder-scoped python.analysis settings that we manage
  const keysToRemove: string[] = [];
  for (const key of Object.keys(workspace.settings)) {
    if (key.startsWith("[") && key.endsWith("]")) {
      const folderName = key.slice(1, -1);
      if (workspaceFolderNames.has(folderName)) {
        const setting = workspace.settings[key];
        if (
          typeof setting === "object" &&
          setting !== null &&
          "python.analysis.extraPaths" in setting
        ) {
          keysToRemove.push(key);
        }
      }
    }
  }

  for (const key of keysToRemove) {
    delete workspace.settings[key];
  }

  let foldersUpdated = 0;

  // Add new folder-scoped extraPaths
  for (const [folderName, deps] of Object.entries(dependencyGraph)) {
    if (deps.length > 0 && workspaceFolderNames.has(folderName)) {
      const key = `[${folderName}]`;
      const extraPaths = deps.map((d) => `\${workspaceFolder:${d}}`);

      workspace.settings[key] = {
        "python.analysis.extraPaths": extraPaths,
      };
      foldersUpdated++;
    }
  }

  const newContent = JSON.stringify(workspace, null, 2) + "\n";

  // Only write if content changed (ignoring whitespace differences)
  if (normalizeJson(content) !== normalizeJson(newContent)) {
    await fs.writeFile(workspacePath, newContent);
    return { updated: true, foldersUpdated };
  }

  return { updated: false, foldersUpdated };
}

/**
 * Remove JSON comments for parsing.
 * VS Code workspace files support comments but JSON.parse doesn't.
 */
function removeJsonComments(content: string): string {
  // Remove single-line comments
  let result = content.replace(/\/\/.*$/gm, "");

  // Remove multi-line comments
  result = result.replace(/\/\*[\s\S]*?\*\//g, "");

  return result;
}

/**
 * Normalize JSON for comparison (parse and re-stringify).
 */
function normalizeJson(content: string): string {
  try {
    const cleaned = removeJsonComments(content);
    return JSON.stringify(JSON.parse(cleaned));
  } catch {
    return content;
  }
}

/**
 * Get the basename of a path (last component).
 */
function getBasename(filePath: string): string {
  const parts = filePath.replace(/\\/g, "/").split("/");
  return parts[parts.length - 1] || parts[parts.length - 2] || "";
}

/**
 * Find the .code-workspace file in a directory.
 */
export async function findWorkspaceFile(
  directory: string,
): Promise<string | undefined> {
  try {
    const entries = await fs.readdir(directory, { withFileTypes: true });

    for (const entry of entries) {
      if (entry.isFile() && entry.name.endsWith(".code-workspace")) {
        return `${directory}/${entry.name}`;
      }
    }
  } catch {
    // Directory doesn't exist or can't be read
  }

  return undefined;
}
